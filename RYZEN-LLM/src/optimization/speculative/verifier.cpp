// Copyright (c) 2024 Ryzanstein LLM Project
// Licensed under MIT License
//
// Speculative Decoding Verification Engine
// [REF:OL-005c] - Optimization Layer: Speculative Decoding
//
// Implements the verification step of speculative decoding where draft tokens
// generated by a fast draft model are verified against the slow target model.
// Uses rejection sampling to ensure output distribution matches target exactly.

#include "verifier.h"

#include <cmath>
#include <algorithm>
#include <numeric>
#include <random>
#include <limits>
#include <cassert>
#include <stdexcept>

namespace ryzanstein_llm
{
    namespace speculative
    {

        // ============================================================================
        // Verifier Constructor & Public Methods
        // ============================================================================

        Verifier::Verifier(const VerifierConfig &config)
            : config_(config), num_verifications_(0), num_rejections_(0)
        {
            // Validate configuration and throw exceptions for invalid values (Release-friendly)
            if (config_.vocab_size == 0)
            {
                throw std::invalid_argument("vocab_size must be > 0");
            }

            if (config_.temperature <= 0.0f)
            {
                throw std::invalid_argument("temperature must be > 0");
            }

            if (config_.rejection_threshold < 0.0f || config_.rejection_threshold > 1.0f)
            {
                throw std::invalid_argument("rejection_threshold must be in [0, 1]");
            }

            // Debug-time assertions (keeps original defensive checks in debug builds)
            assert(config_.vocab_size > 0 && "vocab_size must be > 0");
            assert(config_.temperature > 0.0f && "temperature must be > 0");
            assert(config_.rejection_threshold >= 0.0f && config_.rejection_threshold <= 1.0f && "rejection_threshold must be in [0, 1]");
        }

        VerifierResult Verifier::verify(
            const std::vector<int> &prefix,
            const std::vector<int> &draft_tokens,
            const std::vector<std::vector<float>> &target_logits)
        {

            // Validate inputs
            if (prefix.empty() || draft_tokens.empty() || target_logits.empty())
            {
                return VerifierResult{};
            }

            if (draft_tokens.size() != target_logits.size())
            {
                return VerifierResult{};
            }

            // Validate all tokens are valid
            for (int token : prefix)
            {
                if (token < 0 || token >= static_cast<int>(config_.vocab_size))
                {
                    return VerifierResult{};
                }
            }

            for (int token : draft_tokens)
            {
                if (token < 0 || token >= static_cast<int>(config_.vocab_size))
                {
                    return VerifierResult{};
                }
            }

            for (const auto &logits : target_logits)
            {
                if (logits.size() != config_.vocab_size)
                {
                    return VerifierResult{};
                }
            }

            VerifierResult result;
            std::vector<int> working_prefix = prefix;
            uint32_t num_draft_accepted = 0;

            // Verify each draft token sequentially
            for (size_t i = 0; i < draft_tokens.size(); ++i)
            {
                int draft_token = draft_tokens[i];
                const auto &target_logits_i = target_logits[i];

                // Get target probability distribution
                std::vector<float> target_probs = softmax(target_logits_i);
                if (target_probs.empty())
                {
                    break;
                }

                // Check if draft token is in top-k of target distribution
                bool draft_acceptable = check_acceptance_criteria(
                    draft_token, target_probs);

                if (draft_acceptable)
                {
                    // Token accepted by target model
                    result.accepted_tokens.push_back(draft_token);
                    working_prefix.push_back(draft_token);
                    num_draft_accepted++;
                    num_verifications_++;
                }
                else
                {
                    // Token rejected, but we need to sample a replacement
                    // using the target distribution
                    int replacement_token = rejection_sample(target_probs, draft_token);

                    if (replacement_token >= 0)
                    {
                        result.accepted_tokens.push_back(replacement_token);
                        working_prefix.push_back(replacement_token);
                    }

                    num_verifications_++;
                    num_rejections_++;
                    break; // Stop on first rejection
                }
            }

            result.num_accepted = num_draft_accepted;
            result.acceptance_rate = draft_tokens.size() > 0
                                         ? static_cast<float>(num_draft_accepted) / draft_tokens.size()
                                         : 0.0f;

            return result;
        }

        int Verifier::sample_token(const std::vector<float> &target_logits)
        {
            // Validate input
            if (target_logits.empty())
            {
                return -1;
            }

            // Apply temperature scaling using helper method
            std::vector<float> scaled_logits = apply_temperature(target_logits, config_.temperature);

            // Convert to probabilities with numerical stability
            std::vector<float> probs = softmax(scaled_logits);

            // Use inverse transform sampling (categorical distribution)
            static thread_local std::mt19937 rng(std::random_device{}());
            std::uniform_real_distribution<float> dist(0.0f, 1.0f);
            float u = dist(rng);
            float cumsum = 0.0f;

            for (size_t i = 0; i < probs.size(); ++i)
            {
                cumsum += probs[i];
                if (u <= cumsum)
                {
                    return static_cast<int>(i);
                }
            }

            // Fallback to highest probability token (numerical stability)
            int max_idx = 0;
            float max_prob = 0.0f;
            for (size_t i = 0; i < probs.size(); ++i)
            {
                if (probs[i] > max_prob)
                {
                    max_prob = probs[i];
                    max_idx = static_cast<int>(i);
                }
            }

            return max_idx;
        }

        // ============================================================================
        // Private Helper Methods
        // ============================================================================

        bool Verifier::check_acceptance_criteria(
            int draft_token,
            const std::vector<float> &target_probs)
        {

            // Validate inputs
            if (draft_token < 0 || draft_token >= static_cast<int>(config_.vocab_size))
            {
                return false;
            }

            if (target_probs.size() != config_.vocab_size)
            {
                return false;
            }

            float target_prob = target_probs[draft_token];

            // Simple criterion: accept if target probability is above threshold
            // More sophisticated criterion: use acceptance sampling probability
            // alpha = min(1, target_prob[token] / draft_prob[token])

            // For now, use a simple threshold approach
            // In full implementation, we'd need draft probabilities
            return target_prob >= config_.rejection_threshold;
        }

        int Verifier::rejection_sample(
            const std::vector<float> &target_probs,
            int rejected_token)
        {

            // Validate inputs
            if (target_probs.size() != config_.vocab_size)
            {
                return -1;
            }

            if (rejected_token < 0 || rejected_token >= static_cast<int>(config_.vocab_size))
            {
                return -1;
            }

            // Simple rejection sampling:
            // 1. Sample from target distribution
            // 2. Reject if sample equals rejected_token
            // 3. Repeat until acceptance

            static thread_local std::mt19937 rng(std::random_device{}());
            std::uniform_real_distribution<float> dist(0.0f, 1.0f);

            // Try up to 10 times to find a valid replacement
            for (int attempt = 0; attempt < 10; ++attempt)
            {
                float u = dist(rng);
                float cumulative = 0.0f;

                for (uint32_t i = 0; i < target_probs.size(); ++i)
                {
                    cumulative += target_probs[i];
                    if (u <= cumulative)
                    {
                        int sampled = static_cast<int>(i);
                        if (sampled != rejected_token)
                        {
                            return sampled;
                        }
                        break; // Got rejected token, try again
                    }
                }
            }

            return -1; // Failed to find replacement
        }

        std::vector<float> Verifier::softmax(const std::vector<float> &logits)
        {
            if (logits.empty())
            {
                return {};
            }

            // Numerical stability: subtract max to prevent overflow
            float max_logit = *std::max_element(logits.begin(), logits.end());

            std::vector<float> probs(logits.size());
            float sum_exp = 0.0f;

            for (size_t i = 0; i < logits.size(); ++i)
            {
                float exp_val = std::exp(logits[i] - max_logit);
                probs[i] = exp_val;
                sum_exp += exp_val;
            }

            // Normalize
            if (sum_exp > 0.0f)
            {
                for (float &prob : probs)
                {
                    prob /= sum_exp;
                }
            }
            else
            {
                // Uniform fallback if sum is zero (shouldn't happen)
                float uniform_prob = 1.0f / logits.size();
                std::fill(probs.begin(), probs.end(), uniform_prob);
            }

            return probs;
        }

        std::vector<float> Verifier::apply_temperature(
            const std::vector<float> &logits,
            float temperature)
        {

            if (temperature <= 0.0f)
            {
                return {};
            }

            std::vector<float> scaled(logits.size());
            for (size_t i = 0; i < logits.size(); ++i)
            {
                scaled[i] = logits[i] / temperature;
            }
            return scaled;
        }
        // TODO: Add acceptance statistics

    } // namespace speculative
} // namespace ryzanstein_llm
